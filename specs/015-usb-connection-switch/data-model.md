# Data Model: USB Connection Control Switch

**Date**: 2025-12-16
**Phase**: 1 (Design & Contracts)
**Purpose**: Document entity and state model for USB connection control

## Entity Model

### 1. BuderusUSBConnectionSwitch (New Entity)

**Type**: Home Assistant Switch Entity
**Domain**: `switch`
**Platform**: `buderus_wps`
**Entity ID**: `switch.buderus_wps_usb_connection`

**Attributes**:

| Attribute | Type | Description | Source |
|-----------|------|-------------|--------|
| `name` | `str` | Display name: "USB Connection" | Static class attribute |
| `icon` | `str` | MDI icon: "mdi:usb-port" | Static class attribute |
| `unique_id` | `str` | Unique identifier for entity | Generated by BuderusEntity base |
| `device_info` | `DeviceInfo` | Associated device | Inherited from BuderusEntity |
| `is_on` | `bool` | Connection state (ON=connected, OFF=released) | Computed from coordinator |

**State Logic**:
```python
is_on = not coordinator._manually_disconnected
```

**State Transitions**:
```
    [Initial State: ON]
           │
           ▼
    ┌─────────────┐
    │   ON (True) │◄──── async_turn_on()
    │ Connected   │
    └──────┬──────┘
           │
           │ async_turn_off()
           ▼
    ┌─────────────┐
    │  OFF (False)│◄──── Connection remains released
    │  Released   │
    └──────┬──────┘
           │
           │ async_turn_on()
           ▼
    ┌─────────────┐
    │   ON (True) │
    │ Reconnected │
    └─────────────┘
```

**Actions**:

| Action | Method | Behavior | Exceptions |
|--------|--------|----------|------------|
| Turn ON | `async_turn_on()` | Reconnect to USB port | `HomeAssistantError` if port busy |
| Turn OFF | `async_turn_off()` | Release USB port | None (always succeeds) |

### 2. BuderusCoordinator (Modified)

**Purpose**: Central data coordination with USB connection management

**New State Variables**:

| Variable | Type | Initial Value | Purpose |
|----------|------|---------------|---------|
| `_manually_disconnected` | `bool` | `False` | Track user-initiated disconnect vs failure |

**Existing State Variables** (for reference):

| Variable | Type | Purpose |
|----------|------|---------|
| `_connected` | `bool` | Actual USB connection status |
| `_reconnect_task` | `asyncio.Task \| None` | Background auto-reconnection task |
| `_backoff_delay` | `int` | Current reconnection backoff delay (seconds) |
| `_last_known_good_data` | `BuderusData \| None` | Cached data for graceful degradation |
| `_consecutive_failures` | `int` | Failure counter for error classification |

**New Public Methods**:

| Method | Signature | Purpose | Side Effects |
|--------|-----------|---------|--------------|
| `async_manual_disconnect` | `() -> None` | Release USB port | Sets `_manually_disconnected=True`, cancels reconnection task |
| `async_manual_connect` | `() -> None` | Reconnect USB port | Sets `_manually_disconnected=False`, resets backoff, connects |

**Modified Methods**:

| Method | Modification | Purpose |
|--------|--------------|---------|
| `_reconnect_with_backoff` | Add flag check at loop start (line ~168) | Skip auto-reconnection if manually disconnected |

## State Machine

### Connection State Machine

The coordinator manages connection state with three distinct modes:

```
┌────────────────────────────────────────────────────────────────┐
│                    CONNECTION STATE MACHINE                    │
└────────────────────────────────────────────────────────────────┘

        [Initial: Normal Operation]
                │
                │ USB connection established
                ▼
    ┌───────────────────────────┐
    │   NORMAL OPERATION        │
    │                           │
    │ _connected = True         │
    │ _manually_disconnected    │
    │   = False                 │
    │                           │
    │ • Data flowing            │
    │ • Auto-reconnect enabled  │
    └─────┬──────────────┬──────┘
          │              │
          │              │ User: async_turn_off()
          │              ▼
          │      ┌───────────────────────────┐
          │      │   MANUAL DISCONNECT       │
          │      │                           │
          │      │ _connected = False        │
          │      │ _manually_disconnected    │
          │      │   = True                  │
          │      │                           │
          │      │ • Port released           │
          │      │ • Auto-reconnect DISABLED │
          │      │ • Stale data shown        │
          │      └─────┬─────────────────────┘
          │            │
          │            │ User: async_turn_on()
          │            └──────────┐
          │                       │
          │ Connection            │
          │ failure               │
          ▼                       ▼
    ┌───────────────────────────┐
    │   CONNECTION FAILURE      │
    │                           │
    │ _connected = False        │
    │ _manually_disconnected    │
    │   = False                 │
    │                           │
    │ • Port lost unexpectedly  │
    │ • Auto-reconnect ENABLED  │
    │ • Backoff loop active     │
    └─────┬─────────────────────┘
          │
          │ Auto-reconnect success
          │ or manual connect
          ▼
    ┌───────────────────────────┐
    │   NORMAL OPERATION        │
    │                           │
    │ _connected = True         │
    │ _manually_disconnected    │
    │   = False                 │
    └───────────────────────────┘
```

### State Transition Rules

| From State | Event | To State | Actions |
|------------|-------|----------|---------|
| Normal Operation | User turns switch OFF | Manual Disconnect | Set `_manually_disconnected=True`, cancel reconnect task, call `_sync_disconnect()` |
| Manual Disconnect | User turns switch ON | Normal Operation | Set `_manually_disconnected=False`, reset backoff, call `_sync_connect()` |
| Normal Operation | Connection failure | Connection Failure | Set `_connected=False`, start reconnection task with backoff |
| Connection Failure | Auto-reconnect succeeds | Normal Operation | Set `_connected=True`, clear reconnect task |
| Connection Failure | User turns switch OFF | Manual Disconnect | Set `_manually_disconnected=True`, cancel reconnect task |
| Connection Failure | User turns switch ON | Normal Operation (attempt) | Set `_manually_disconnected=False`, immediate connect (may fail to Manual Disconnect) |

### State Invariants

**Invariant 1**: `_manually_disconnected` implies `not _connected`
- Manual disconnect always disconnects first
- Cannot be manually disconnected while connected

**Invariant 2**: `_reconnect_task` is None when `_manually_disconnected` is True
- Auto-reconnection stops when manual disconnect active
- Task cancelled on manual disconnect

**Invariant 3**: Switch `is_on` matches `not _manually_disconnected`
- Switch OFF state persists across connection failures
- Switch ON state represents intent to stay connected

## Data Flow

### Manual Disconnect Flow

```
User clicks switch OFF in UI
    │
    ▼
switch.async_turn_off()
    │
    ▼
coordinator.async_manual_disconnect()
    │
    ├─► Set _manually_disconnected = True
    │
    ├─► Cancel _reconnect_task (if active)
    │
    ├─► if _connected:
    │       └─► hass.async_add_executor_job(_sync_disconnect)
    │           └─► _connected = False
    │
    └─► Log: "Manual disconnect: USB port released"
    │
    ▼
Switch updates UI to OFF
    │
    ▼
Next coordinator update cycle:
    │
    ├─► Check: if not _connected
    │       └─► Check: if _manually_disconnected
    │               └─► Return _last_known_good_data (stale)
    │
    ▼
Sensors show stale data (not unavailable)
    │
    ▼
CLI tool can now access USB port
```

### Manual Reconnect Flow

```
User clicks switch ON in UI
    │
    ▼
switch.async_turn_on()
    │
    ▼
coordinator.async_manual_connect()
    │
    ├─► Set _manually_disconnected = False
    │
    ├─► Reset _backoff_delay = BACKOFF_INITIAL
    │
    ├─► hass.async_add_executor_job(_sync_connect)
    │   │
    │   ├─► Success: _connected = True
    │   │
    │   └─► Failure: Raises DeviceNotFoundError
    │           └─► Caught by switch.async_turn_on()
    │               └─► Logs warning, raises HomeAssistantError
    │                   └─► Switch stays OFF, user sees error
    │
    └─► Log: "Manual connect: USB port reconnected"
    │
    ▼
Switch updates UI to ON
    │
    ▼
Next coordinator update cycle:
    │
    ├─► _connected = True
    │       └─► Fetch fresh data
    │           └─► Update _last_known_good_data
    │
    ▼
Sensors show fresh data
```

### Auto-Reconnection Interaction

```
Connection failure occurs
    │
    ▼
coordinator._handle_connection_failure()
    │
    ├─► Set _connected = False
    │
    └─► Create _reconnect_task
        │
        ▼
    _reconnect_with_backoff() loop:
        │
        ├─► while not _connected:
        │   │
        │   ├─► Check: if _manually_disconnected  ◄─── CRITICAL CHECK
        │   │       └─► Log: "Skipping auto-reconnect"
        │   │       └─► Set _reconnect_task = None
        │   │       └─► return (exit loop)
        │   │
        │   ├─► sleep(_backoff_delay)
        │   │
        │   ├─► Try: _sync_connect()
        │   │   ├─► Success: _connected = True (exit loop)
        │   │   └─► Failure: Double backoff, retry
        │   │
        │   └─► Loop continues...
        │
        └─► _reconnect_task = None
```

## Data Types

### BuderusData (Existing)

**Purpose**: Cached data structure for graceful degradation

```python
@dataclass
class BuderusData:
    """Data class for heat pump readings."""

    temperatures: dict[str, float | None]
    compressor_running: bool
    energy_blocked: bool
    dhw_extra_duration: int  # Hours remaining (0-24)
    heating_season_mode: int | None  # 0=Winter, 1=Auto, 2=Off
    dhw_program_mode: int | None  # 0=Auto, 1=On, 2=Off
```

**Relevance**: Returned during manual disconnect (stale data) to keep sensors responsive.

### DeviceInfo (Home Assistant)

**Purpose**: Device registry information

```python
DeviceInfo(
    identifiers={(DOMAIN, coordinator.port)},
    name="Buderus WPS Heat Pump",
    manufacturer="Buderus",
    model="WPS",
    sw_version="Unknown"
)
```

**Relevance**: USB connection switch appears under same device as sensors.

## Persistence

### Non-Persistent State

**`_manually_disconnected` flag is NOT persistent across Home Assistant restarts.**

**Rationale** (from spec.md Out of Scope):
- Restarts are rare
- Default should be "connected" (safer)
- Acceptable limitation

**Behavior on Restart**:
1. Home Assistant restarts
2. Coordinator initializes with `_manually_disconnected = False`
3. Coordinator attempts connection in `async_setup()`
4. Switch initializes to ON state
5. If restart happened while debugging, user must toggle OFF again

**Alternative Considered**: Store state in config entry data
- **Rejected**: Adds complexity for rare edge case
- Config entry modifications require reload
- Not worth implementation cost

### Cached Data Persistence

**`_last_known_good_data` is persistent in memory during HA runtime.**

**Behavior**:
- Survives across connection state changes
- Cleared only on coordinator shutdown or successful data fetch
- Enables seamless transition from disconnected → connected
- No disk persistence (lost on HA restart)

## Entity Registry

### Unique ID Generation

**Pattern** (from BuderusEntity base class):
```python
@property
def unique_id(self) -> str:
    """Return unique ID."""
    return f"{self.coordinator.port}_{self._attr_name.lower().replace(' ', '_')}"
```

**Result for USB Connection Switch**:
```
/dev/ttyACM0_usb_connection
```

**Stability**: Unique ID remains constant across HA restarts, preserving entity history.

### Device Association

**All entities (sensors, switches) belong to same device:**
- Device ID: `(DOMAIN, coordinator.port)`
- Device Name: "Buderus WPS Heat Pump"

**Benefit**: User sees all controls grouped under single device in UI.

## Error States

### Port Busy Error

**Scenario**: CLI tool has port open when user toggles switch ON

**State Before**:
- `_manually_disconnected = True`
- `_connected = False`
- Switch UI: OFF

**State After** (error):
- `_manually_disconnected = False` (cleared before connection attempt)
- `_connected = False` (connection failed)
- Switch UI: OFF (stays OFF due to exception)

**Data Flow**:
```
switch.async_turn_on()
    │
    ▼
coordinator.async_manual_connect()
    │
    ├─► Set _manually_disconnected = False
    │
    └─► _sync_connect() raises DeviceNotFoundError
        │
        ▼
Exception bubbles to switch
    │
    ▼
switch catches and logs
    │
    └─► Raises HomeAssistantError("USB port in use")
        │
        ▼
    Home Assistant keeps switch OFF
    └─► User sees "Failed" in UI
```

**Recovery**: User closes CLI, toggles switch ON again successfully.

## Summary

**Key Entities**:
- 1 new switch entity (BuderusUSBConnectionSwitch)
- 1 modified coordinator (add 1 flag, 2 methods, 1 check)

**State Variables**:
- `_manually_disconnected`: Boolean flag tracking user intent
- Interacts with existing `_connected`, `_reconnect_task`

**State Machine**:
- Three states: Normal, Manual Disconnect, Connection Failure
- Clear transitions based on user actions and connection events

**Data Flow**:
- Manual disconnect → stale data → reconnect → fresh data
- Auto-reconnection respects manual disconnect flag

**Persistence**:
- Non-persistent across restarts (acceptable trade-off)
- Cached data persistent in memory during runtime
