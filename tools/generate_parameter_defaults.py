#!/usr/bin/env python3
"""
Parse FHEM 26_KM273v018.pm and emit buderus_wps/parameter_defaults.py.

This is a one-off helper to snapshot the KM273_elements_default table into a
Python module so the library has a baseline registry even before fetching from
the heat pump. Run from repository root:

    python tools/generate_parameter_defaults.py
"""

from __future__ import annotations

import argparse
import json
import pathlib
import re
from dataclasses import dataclass
from typing import List, Dict, Any, Tuple, Set

ROOT = pathlib.Path(__file__).resolve().parent.parent
SOURCE = ROOT / "fhem" / "26_KM273v018.pm"
TARGET = ROOT / "buderus_wps" / "parameter_defaults.py"
META = ROOT / "buderus_wps" / "parameter_defaults.meta.json"

ENTRY_REGEX = re.compile(
    r"\{\s*'idx'\s*=>\s*(?P<idx>-?\d+)\s*,\s*"
    r"'extid'\s*=>\s*'(?P<extid>[A-F0-9]+)'\s*,\s*"
    r"'max'\s*=>\s*(?P<max>-?\d+)\s*,\s*"
    r"'min'\s*=>\s*(?P<min>-?\d+)\s*,\s*"
    r"'format'\s*=>\s*'(?P<format>[^']+)'\s*,\s*"
    r"'read'\s*=>\s*(?P<read>-?\d+)\s*,\s*"
    r"'text'\s*=>\s*'(?P<text>[^']+)'\s*\}"
)


def extract_entries(text: str) -> List[Dict[str, Any]]:
    matches = ENTRY_REGEX.finditer(text)
    entries = []
    for m in matches:
        entries.append(
            {
                "idx": int(m.group("idx")),
                "extid": m.group("extid"),
                "max": int(m.group("max")),
                "min": int(m.group("min")),
                "format": m.group("format"),
                "read": int(m.group("read")),
                "text": m.group("text"),
            }
        )
    return entries


def validate_entries(entries: List[Dict[str, Any]], source_text: str) -> None:
    """Validate extracted entries against expectations."""
    if not entries:
        raise SystemExit("No entries parsed; pattern may be incorrect.")

    # simple sanity: ensure unique idx and extid/text combos
    idx_set: Set[int] = set()
    dup_idx = []
    for e in entries:
        if e["idx"] in idx_set:
            dup_idx.append(e["idx"])
        idx_set.add(e["idx"])
    if dup_idx:
        raise SystemExit(f"Duplicate idx detected: {dup_idx}")

    # count check vs direct regex count
    regex_count = len(ENTRY_REGEX.findall(source_text))
    if len(entries) != regex_count:
        raise SystemExit(
            f"Entry count mismatch: parsed {len(entries)} vs regex matches {regex_count}"
        )


def load_existing() -> List[Dict[str, Any]]:
    if not TARGET.exists():
        return []
    # Crude import by exec to avoid import-time side effects
    data: dict = {}
    code = TARGET.read_text(encoding="utf-8")
    exec(compile(code, str(TARGET), "exec"), data)
    return data.get("PARAMETER_DEFAULTS", [])


def diff_entries(old: List[Dict[str, Any]], new: List[Dict[str, Any]]) -> Tuple[List[Dict[str, Any]], List[Dict[str, Any]], List[Tuple[Dict[str, Any], Dict[str, Any]]]]:
    old_by_text = {e["text"]: e for e in old}
    new_by_text = {e["text"]: e for e in new}
    added = [v for k, v in new_by_text.items() if k not in old_by_text]
    removed = [v for k, v in old_by_text.items() if k not in new_by_text]
    modified = []
    for text, new_entry in new_by_text.items():
        old_entry = old_by_text.get(text)
        if not old_entry:
            continue
        # compare fields
        if any(new_entry[f] != old_entry.get(f) for f in ("idx", "extid", "min", "max", "format", "read")):
            modified.append((old_entry, new_entry))
    return added, removed, modified


def write_module(entries: List[Dict[str, Any]]) -> None:
    header = (
        "# Auto-generated by tools/generate_parameter_defaults.py\n"
        "# Do not edit manually. Source: fhem/26_KM273v018.pm\n\n"
        "PARAMETER_DEFAULTS = [\n"
    )
    lines = [header]
    for entry in entries:
        lines.append(
            f"    {{'idx': {entry['idx']}, 'extid': '{entry['extid']}', "
            f"'max': {entry['max']}, 'min': {entry['min']}, "
            f"'format': '{entry['format']}', 'read': {entry['read']}, "
            f"'text': '{entry['text']}' }},\n"
        )
    lines.append("]\n")
    TARGET.write_text("".join(lines), encoding="utf-8")
    print(f"Wrote {len(entries)} entries to {TARGET}")

    meta = {
        "count": len(entries),
        "source": str(SOURCE),
    }
    META.write_text(json.dumps(meta, indent=2), encoding="utf-8")
    print(f"Wrote metadata to {META}")


def main() -> None:
    parser = argparse.ArgumentParser(description="Generate parameter_defaults.py from fhem/26_KM273v018.pm")
    parser.add_argument("--summary", action="store_true", help="Print change summary vs existing defaults")
    args = parser.parse_args()

    text = SOURCE.read_text(encoding="utf-8")
    entries = extract_entries(text)
    validate_entries(entries, text)
    old_entries = load_existing()
    added, removed, modified = diff_entries(old_entries, entries)
    if args.summary:
        print(f"Existing: {len(old_entries)} entries; New: {len(entries)} entries")
        print(f"Added: {len(added)}; Removed: {len(removed)}; Modified: {len(modified)}")
    write_module(entries)


if __name__ == "__main__":
    main()
